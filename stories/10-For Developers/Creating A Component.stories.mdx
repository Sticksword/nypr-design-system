import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="For Developers/Creating a Component" />

# Creating a Component

This document lays out step by step guidelines and best practices for creating Radial components. Taking a consistent approach to components will makes the design system easier to learn and use. 

## Naming Components

Radial component names use UpperCamelCase, with no special prefix. They're namespaced by their place in the atomic design heirarchy. To keep atoms extra easy to use, skip extra namespacing and just use the component name. For molecules and organisms, namespace them by putting them in folders, named molecule, or component.

| Filename | Component Syntax |
|---|---|
| button               |   `<Button />`               |
| molecule/byline      |   `<Molecule::Byline />`     |
| organism/newsletter  |   `<Organism::Newsletter />` |

## Creating the component skeleton

In Ember you can generate component boilerplate with the following command:

```ember g component button --pod````

Now, in the component template give your component a top level HTML tag, a class, and `...attributes`.
The outer element of your component's class should have the same name as the component, but in kebab-case. (e.g. `<div class="breaking-news">`).
This will gives you a very bare bones component to start with, so storybook doesn't throw errors when you write your stories.

```html
<button class="button" ...attributes></button>
```
   
## Create stories in Storybook

Storybook allows us to prototype and build out our component with multiple variations

Stories are living examples that demonstrate the different variations of a component. Use design comps as a guide to which stories to include. For example, consider these button designs:

<img alt="List" src="./images/button-design-example.png" width="200" />

Based on these designs you could write stories for the different button types (primary, primary with icon, secondary, icon, and flat) and include variations for the three different sizes within each story.

Stories are written in blocks of code that go directly into your MDX documentation.

```hbs
import { Preview, Story } from '@storybook/addon-docs/blocks';

<Preview withToolbar={true}>
  <Story name="header-default" height="200px">{{
    template: hbs`<Button @label="Button" class="mod-large" />`
  }}</Story>
</Preview>
```

Don't worry that your component code is still only a skeleton, write your stories with the properties and classes you would expect the component to have to show these variations. You can always go back and change it later if your component development takes a different direction.

```hbs
<Button @icon="audio" @iconAlt="Play" class="mod-large"/>
```

Even if you don't know if the finished component will end up having a property called iconAlt, you can make a guess and you can always change it later.

If you need to mock larger data structures in your stories you can use a context object. A context object is a javascript object containing properties that a story's template can access.

```html
<Preview withToolbar={true}>
  <Story name="header-default" height="200px">{{
    template: hbs`<ArticleHeader @article={{story}} />`,
    context: {
        story: {
            title: 'Scientists Find New Lifeform in Sewers',
            authors: [{name:'Ben Yakas'}]
            // etc...
        }
    }
  }}</Story>
</Preview>
```

Further Reading:

- [Writing MDX stories in Ember](https://github.com/storybookjs/storybook/blob/next/addons/docs/ember/README.md#mdx)


# Write your component code

## Starting your local development servers

First, start Ember so it can rebuild your component whenever you make changes.

```
ember s
```

Then, start Storybook, and navigate to the stories you created. Now you go back to your component template in your editor of choice. As you update your component's code, its stories will update live on the story page.


## Styles
  Each component's styles should live in their own file. Add a stylesheet for your component in `/app/styles/_library/components/`. This will be a sass partial, so the filename should start with an underscore. e.g. `app/styles/_library/components/_button.scss`.

  All components are imported into the final stylesheet in `app/styles/_library/_components.scss`. Add an import for the component here.

```scss
//app/styles/_library/_components.scss

@import "./components/button";

```

Every element should have a class. This allows for easier targeting not just in your stylesheets and themes but also in automated testing and analytics tools. Use the [Trello styleguide's convention](https://github.com/trello/trellisheets/blob/master/styleguide.md#2-components), `.component-descendant-descendant`, for naming your classes.
```html
<button class="button" ...attributes>
    <Icon class="button-icon" @name={@icon} />
    <span class="button-label">{{@label}}</span>
</button>
```

Provide modifier classes for alternate styling when possible. Again, use the [Trello styleguide's naming convention](https://github.com/trello/trellisheets/blob/master/styleguide.md#modifiers), `.component-descendant.mod-modifier`.

Taking this component template,

```html
<button class="button" ...attributes>{{@labe}}</button>
```

and this component invocation,

```html
<Button class="mod-large" />
```

the `...attributes` syntax will merge the classes, so you can style this button with a selector of `.button.mod-large`.

## Tokens

Use *tokens* to define style values where possible. Cross reference the design comps with the [token list](/docs/for-developers-token-reference--page), and consult with a designer if necessary to help find the appropriate token values. 

```scss
.button {}
  padding: var(--space-1) var(--space-4);
  color: rgb(var(--color-button-text));
  background-color: rgb(var(--color-button));
  // ... and so on
}
```

## Optional properties

Sometimes a component has properties that are optional, such as an icon or secondary title. Use a template conditional to hide the elements that display these properties when they don't exist.

```hbs
{{if @icon}}
    <Icon @name={@icon} />
{{/if}}
```

When it makes sense, you can handle even larger variations with template conditionals. Try to keep your components dumb and avoid unecessary controller code if something can be done in the template. In the following example, the conditianal checks for the presence of an href property and changes the base element for the component to a link if it has a link.

```hbs
{{if @href}}
    <a class="button" ...attributes>{{@label}}</a>
{{else}}
    <button class="button" ...attributes>{{@label}}</button>
{{/if}}
```

## States

 Certain states on a component might affect how its displayed, for example a menu that can be open or closed. Use code to conditionally provide css classes that indicates these states as hooks for styling. Again use the [Trello Style guide's Naming convention](https://github.com/trello/trellisheets/blob/master/styleguide.md#state), `.component-descendant.is-state`.

## Events

In the case of something like a simple button component, `...attributes` on the button element makes all the HTML button events available at the component level. But for more complex components, you want to pass events up to the component level. Take a newsletter form for example. You want to expose events like onSubmit, onSuccess, onError, and so on. This allows clients using the component a way to access these events.

```html
<Newsletter @onSuccess={{fn this.trackEvent 'NewsletterSubscribe,Footer'}} />
```

todo: still need to figure out what is a good way to implement something like this.

## Documenting your component's code

Use YUIdoc comments to document public properties in the component's `js` file. Include all properties that can be passed into a component here, even ones that are only referenced in code in the `hbs` templates.

YUIdoc examples for ember classes and components:
https://github.com/ember-learn/ember-cli-addon-docs-yuidoc#documenting-components

Example component YUIdoc comment:
``````js
/**
  Component description.....

  Usage:
  ```
  <NyprAButton>
    Click Me
  </NyprAButton>
  ```

  @class nypr-a-button
  @yield {Block} block
*/
export default Component.extend({
//...
``````

Example property YUIDoc comment:
```js
/**
Title for the component, plain text.

@argument title
@type {String}
*/
title: '',
```

## Write Tests

Don't forget to write tests for your component. Test the various states and conditions you have in your template. For example in the case of the button you might want to test a button without an icon, and a button without a label, and a button with both. You should also test any events you pass out of your component to make sure they are firing correctly. You *don't* need to test style based variations, like the large button and small button.

### ember-a11y-testing

You should use [ember-a11y-testing](https://github.com/ember-a11y/ember-a11y-testing) to test the accessibility of your component. It usually only requires adding `await a11yAudit();` to a test.
