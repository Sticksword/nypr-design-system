import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Foundations/Developing New Components" />

# Developing New Components

<div style={{border: '1px solid #ccc', padding: '1em 0', margin: '1em', textAlign: 'center'}}>
	ðŸš§ This doc is a work in progress. Feedback is welcome! ðŸš§
</div>

## Documenting Your Components

### Component Properties

Use YUIdoc comments to document public properties in the component's `js` file. Include all properties that can be passed into a component here, even ones that are only referenced in code in the `hbs` templates.

YUIdoc examples for ember classes and components:
https://github.com/ember-learn/ember-cli-addon-docs-yuidoc#documenting-components

Example:
```js
/**
Title for the component, plain text.

@argument title
@type {String}
*/
```

### Creating a Story File
TODO

## Creating Flexibile but Focused Components

### Components should adapt to their inputs.

Missing a title property? The component should display without it's title block. No author property? Hide the author area. etc. Using a component with no properties shouldn't cause any console errors. This lets components provide flexibility without extra configuration.


### Vary presentation using CSS classes

Component variants should generally be doable with CSS. 
`a-button--primary`, `a-button--secondary`, `a-button--ghost`, etc... If you're thinking about using a component property to toggle between different visual modes of a component, you might just consider two different components.

### Avoid higher-order components

Higher order components are great for building other components, but can be a complicated to use on their own.  Most components won't require the level of flexibility that the higher order component pattern provides, and multiple yielded blocks can bloat templates. At least provide a no-blocks-required fallback.

```html
<!-- GOOD -->
<SimpleCard @article={{article}} / >

<!-- GOOD -->
<SimpleCard
	@title={{article.title}}
	@img={{article.img}}
	@alt={{article.alt}}
	@desc={{article.desc}}
/>

<!-- CAUTION -->
<SimpleCard as |card|>
	<card.title>{{@article.title}}</card.title>
	<card.image><img src="{{@article.img}}" alt="@article.alt"></card.image>
	<card.desc>@article.caption</card.desc>
</SimpleCard>
```

## Handling our Content

### Accept standard content objects

Components should accept objects straight from our most common APIs. Our APIs may change over time, but right now articles should match Wagtail articles. This makes components easier to use in our clients and also makes it easier to handle list components.

If a component is meant for more than just that object type (e.g. a card might display articles, but also authors), also accepting individual properties is great.

```html
<SimpleCard @item={{wagtailArticle}} />

<SimpleCard
	@title={{article.title}}
	@img={{article.img}}
	@alt={{article.alt}}
	@desc={{article.desc}}
/>
```

Client applications can build template helpers to handle special cases.

```html
<SimpleCard @item={{legacy-article-card-adapter legacyArticle}} />
<SimpleCard @item={{author-card-adapter wagtailAuthor}} />
```

Sample code for one of these adapters helpers...
```js
//TODO
```


## Other Patterns

### Interactive components should expose appropriate events as part of their public interface.

For example, forms should have `onSubmit` and `onError` properties. Other components with interactive behaviours should expose events as appropriate. This allows us to hook up things like analytics more easily.

### Handle links with the 'link helper'

This doesn't exist yet. This lets you automatically treat both internal ember routes (i.e. An array of routing parameters, ['tags', 'mta']) and external urls appropriately, without a lot of extra logic in the clients or components.

```html
<!-- my-component.hbs -->
<h1>{{link @link @linktext}}</h1>
```

## CSS

### BEM class naming

### Prefixes

Inspired by the philosophy of ITSCSS, but modified to fit an atomic design pattern.

### Avoid `&`, the Sass 'parent selector', especially as a class prefix.
The [Sass parent selector](https://sass-lang.com/documentation/style-rules/parent-selector) can be a nice shorcut for small blocks, but once a section of code is longer than will fit on the screen, it means you have to scroll up to see what it refers to. When used as part of a class names it also breaks searching for a specific class.

```sass
/* BAD */
.o-my-component {
    &__message {
        color: var(--c-alert);
    }
}

/* GOOD */
.o-my-component {
    .o-my-component__message {
        color: var(--c-alert);
    }
}
```

## Testing
TODO

## Accessibility
TODO
